<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EvoSoup Visualization</title>
    <style>
        body { font-family: monospace; background-color: #2e2e2e; color: #d3d3d3; margin: 0; overflow: hidden; }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        label { display: block; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="soupCanvas"></canvas>
    </div>
    <div id="controls">
        <h1>EvoSoup</h1>
        <p>Generation: <span id="gen">0</span></p>
        <p>Steps/sec: <span id="steps">0</span></p>
        <p>Entropy: <span id="entropy">0.00</span></p>
        <label for="jumpRate">Jump Interval (Î¼s): <span id="jumpRateValue">1000</span></label>
        <input type="range" id="jumpRate" min="0" max="100" step="1" value="50">
        <div id="opcode-legend"></div>
    </div>

    <script>
        // --- Canvas and WebSocket Setup ---
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('soupCanvas');
        const ctx = canvas.getContext('2d');

        // Offscreen canvas for holding the raw soup image
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        const opcodeColors = [
            [46, 46, 46, 255],      // 0: NOOP (Dark Gray)
            [117, 80, 123, 255],    // 1: ADD (Purple-ish)
            [204, 0, 0, 255],       // 2: SUB (Red)
            [245, 121, 0, 255],     // 3: JUMP_REL_IF_LT_ZERO (Orange)
            [0, 255, 255, 255],     // 4: AND (Cyan)
            [255, 0, 255, 255],     // 5: OR (Magenta)
            [128, 0, 128, 255],     // 6: XOR (Dark Purple)
            [0, 128, 128, 255],     // 7: NOT (Teal)
            [52, 101, 164, 255],    // 8: LOAD_VAL_FROM_ADDR (Blue)
            [196, 160, 0, 255],     // 9: LOAD_ADDR_FROM_ADDR (Yellow)
            [78, 154, 6, 255],      // 10: LOAD_VAL_IMMEDIATE (Green)
            [164, 0, 0, 255],       // 11: LOAD_ADDR_IMMEDIATE (Dark Red)
            [255, 255, 255, 255],   // 12: WRITE_VAL_TO_ADDR (White)
        ];

        const opcodeNames = [
            "NOOP",
            "ADD",
            "SUB",
            "JUMP_REL_IF_LT_ZERO",
            "AND",
            "OR",
            "XOR",
            "NOT",
            "LOAD_VAL_FROM_ADDR",
            "LOAD_ADDR_FROM_ADDR",
            "LOAD_VAL_IMMEDIATE",
            "LOAD_ADDR_IMMEDIATE",
            "WRITE_VAL_TO_ADDR",
        ];

        // --- Data Display & Controls ---
        const genSpan = document.getElementById('gen');
        const stepsSpan = document.getElementById('steps');
        const entropySpan = document.getElementById('entropy');
        const jumpRateSlider = document.getElementById('jumpRate');
        const jumpRateValueSpan = document.getElementById('jumpRateValue');
        const opcodeLegendDiv = document.getElementById('opcode-legend');

        // Generate opcode legend
        opcodeNames.forEach((name, index) => {
            const color = opcodeColors[index];
            if (color) {
                const colorBox = `<span style="display:inline-block; width:12px; height:12px; background-color:rgba(${color.join(',')}); border:1px solid #777; vertical-align:middle; margin-right:5px;"></span>`;
                const legendItem = document.createElement('div');
                legendItem.innerHTML = `${colorBox}${name}`;
                opcodeLegendDiv.appendChild(legendItem);
            }
        });

        // --- View State ---
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let soupWidth = 0;
        let soupHeight = 0;

        // --- WebSocket Connection ---
        const socket = new WebSocket('ws://localhost:8080/ws');
        socket.binaryType = 'arraybuffer';

        let imageData;
        let imageDataBuffer;

        function draw() {
            if (!soupWidth) return;

            // Set canvas size to fill container
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            // --- Disable image smoothing for crisp pixels ---
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false; // For Safari
            ctx.mozImageSmoothingEnabled = false;    // For Firefox

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            ctx.drawImage(offscreenCanvas, 0, 0);
            ctx.restore();
        }

        socket.onmessage = function(event) {
            if (typeof event.data === 'string') {
                const stats = JSON.parse(event.data);
                genSpan.textContent = stats.Generation;
                stepsSpan.textContent = (stats.StepsPerSecond).toLocaleString(); // Update to show steps per second
                entropySpan.textContent = stats.Entropy.toFixed(2);
            } else if (event.data instanceof ArrayBuffer) {
                const colorIndices = new Uint8Array(event.data);
                const soupSize = colorIndices.length;
                const canvasSize = Math.sqrt(soupSize);

                if (!imageData || soupWidth !== canvasSize) {
                    soupWidth = canvasSize;
                    soupHeight = canvasSize;
                    offscreenCanvas.width = soupWidth;
                    offscreenCanvas.height = soupHeight;
                    imageData = offscreenCtx.createImageData(soupWidth, soupHeight);
                    imageDataBuffer = imageData.data;
                    // Center the initial view
                    offsetX = (canvasContainer.clientWidth - soupWidth * zoom) / 2;
                    offsetY = (canvasContainer.clientHeight - soupHeight * zoom) / 2;
                }

                for (let i = 0; i < soupSize; i++) {
                    const colorIndex = colorIndices[i] < opcodeColors.length ? colorIndices[i] : 0;
                    const color = opcodeColors[colorIndex];
                    const pixelIndex = i * 4;
                    imageDataBuffer[pixelIndex]     = color[0];
                    imageDataBuffer[pixelIndex + 1] = color[1];
                    imageDataBuffer[pixelIndex + 2] = color[2];
                    imageDataBuffer[pixelIndex + 3] = color[3];
                }
                offscreenCtx.putImageData(imageData, 0, 0);
                requestAnimationFrame(draw);
            }
        };

        // --- Event Listeners ---

        // Pan
        canvasContainer.addEventListener('mousedown', (e) => {
            isPanning = true;
            canvasContainer.style.cursor = 'grabbing';
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvasContainer.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mouseleave', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            offsetX += dx;
            offsetY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(draw);
        });

        // Zoom
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Position of the mouse relative to the zoomed image
            const mouseXInImage = (mouseX - offsetX) / zoom;
            const mouseYInImage = (mouseY - offsetY) / zoom;

            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            const newZoom = zoom * zoomFactor;

            // Clamp zoom level
            const maxZoom = 32;
            const minZoom = canvasContainer.clientWidth / 1024; // Ensure it doesn't get smaller than the view
            zoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            // Adjust offset to keep the mouse position constant
            offsetX = mouseX - mouseXInImage * zoom;
            offsetY = mouseY - mouseYInImage * zoom;

            requestAnimationFrame(draw);
        });

        // Logarithmic scale conversion functions
        const minLog = Math.log(1);
        const maxLog = Math.log(1000000);
        const minSlider = 0;
        const maxSlider = 100;

        function calculateLogFrequency(sliderValue) {
            const scale = (maxLog - minLog) / (maxSlider - minSlider);
            const logValue = minLog + scale * (sliderValue - minSlider);
            return Math.round(Math.exp(logValue));
        }

        function calculateSliderValue(logFrequency) {
            const scale = (maxSlider - minSlider) / (maxLog - minLog);
            const sliderValue = minSlider + scale * (Math.log(logFrequency) - minLog);
            return Math.round(sliderValue);
        }

        // Jump Rate Slider
        jumpRateSlider.addEventListener('input', (e) => {
            const linearSliderValue = parseInt(e.target.value);
            const newFreq = calculateLogFrequency(linearSliderValue);
            jumpRateValueSpan.textContent = newFreq;
            const message = {
                type: "set_jump_rate",
                value: newFreq
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });
        
        // Resize Observer
        new ResizeObserver(draw).observe(canvasContainer);


        socket.onopen = function(event) {
            console.log("WebSocket connection established.");
            // Set initial jump rate on the server and UI
            // Calculate initial slider value based on default frequency (1)
            const initialFreq = 1; // This should match the default in vm/vm.go
            jumpRateSlider.value = calculateSliderValue(initialFreq);
            jumpRateValueSpan.textContent = initialFreq;
            jumpRateSlider.dispatchEvent(new Event('input'));
        };

        socket.onerror = function(error) {
            console.error("WebSocket Error: ", error);
        };
    </script>
</body>
</html>
