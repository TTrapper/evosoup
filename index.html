<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EvoSoup Visualization</title>
    <style>
        body { font-family: monospace; background-color: #2e2e2e; color: #d3d3d3; margin: 0; overflow: hidden; }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        label { display: block; margin-bottom: 5px; }
        #controls-buttons button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            width: 80px; /* Give button a fixed width */
        }
        #controls-buttons button:hover {
            background-color: #777;
        }
        #paging-controls {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        #paging-controls button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #paging-controls button:hover {
            background-color: #777;
        }
        #paging-controls button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }
        #paging-controls span {
            margin: 0 10px;
            font-weight: bold;
        }
        #addressing-modes label {
            margin-right: 10px;
        }

        #trackedIpState p {
            margin: 5px 0;
        }
        #right-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px; /* Adjust as needed */
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            color: #d3d3d3;
        }
        #right-panel h2,
        #right-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #eee;
        }
        #right-panel p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="soupCanvas"></canvas>
    </div>
    <div id="controls">
        <h1>EvoSoup</h1>
        <p>Generation: <span id="gen">0</span></p>
        <p>Steps/sec: <span id="steps">0</span></p>
        <p>Entropy: <span id="entropy">0.00</span></p>
        <label for="jumpFailureProbability">Jump Failure Rate: <span id="jumpFailureProbabilityValue">50</span>%</label>
        <input type="range" id="jumpFailureProbability" min="0" max="100" step="1" value="50">
        <div id="controls-buttons">
            <button id="playPauseButton">Pause</button>
        </div>
        <div id="paging-controls">
            <button id="prevPage">&lt;</button>
            <span id="pageInfo">Page ? / ?</span>
            <button id="nextPage">&gt;</button>
        </div>
        <div id="addressing-modes">
            <label><input type="checkbox" id="32BitAddressing"> 32-bit Addressing</label>
            <label><input type="checkbox" id="relativeAddressing" checked> Relative Addressing</label>
        </div>
        <div id="view-mode-controls">
            <label><input type="radio" name="viewMode" value="opcode" checked> Opcodes</label>
            <label><input type="radio" name="viewMode" value="heatmap"> Heatmap</label>
        </div>
        <div id="opcode-legend"></div>
    </div>

    <div id="right-panel" style="display: none;">
        <h2>Tracked IP State</h2>
        <div id="trackedIpState">
            <p>ID: <span id="trackedIpId">-</span></p>
            <p>Current Ptr: <span id="trackedIpCurrentPtr">-</span></p>
            <p>Instruction: <span id="trackedIpInstruction">-</span></p>
            <button id="stepButton">Step</button>
            <label><input type="checkbox" id="followIpCheckbox" checked> Follow IP</label>
        </div>
        <h3>Instruction History</h3>
        <div id="instructionHistory" style="max-height: 200px; overflow-y: scroll; border: 1px solid #555; padding: 5px;"></div>
    </div>

    <script>
        // --- Canvas and WebSocket Setup ---
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('soupCanvas');
        const ctx = canvas.getContext('2d');

        // Offscreen canvas for holding the raw soup image
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        const opcodeColors = [
            [46, 46, 46, 255],      // 0: NOOP (Dark Gray)
            [52, 101, 164, 255],    // 1: MOV (Blue)
            [255, 255, 255, 255],   // 2: WRT (White)
            [78, 154, 6, 255],      // 3: INC (Green)
            [115, 210, 22, 255],    // 4: DEC (Lighter Green)
            [0, 255, 255, 255],     // 5: XOR (Cyan)
            [0, 128, 128, 255],     // 6: SHF (Teal)
            [100, 200, 200, 255],   // 7: INV (Lighter Teal)
            [245, 121, 0, 255],     // 8: JMP_Z (Orange)
            [204, 0, 0, 255],       // 9: ADD (Red)
            [255, 102, 102, 255],   // 10: SUB (Lighter Red)
            [102, 51, 0, 255],      // 11: AND (Brown)
            [153, 102, 51, 255],    // 12: OR (Lighter Brown)
            [191, 0, 255, 255],     // 13: JMP (Purple)
            [255, 128, 255, 255],   // 14: JMP_NZ (Pink)
            [0, 153, 0, 255],       // 15: PUSH (Dark Green)
            [255, 80, 80, 255],     // 16: POP (Lighter Red)
            [0, 0, 204, 255],       // 17: CALL (Dark Blue)
            [102, 102, 255, 255]    // 18: RET (Lighter Blue/Purple)
        ];

        let opcodeNames = []; // Will be populated from websocket
        let opcodeData = [];

        function getHeatmapColor(value) {
            let r = 0, g = 0, b = 0;
            const alpha = 255;
            // Handle positive values (0 to 127): transition from black to red
            if (value > 0) {
                const intensity = value / 127.0;
                r = 255 * intensity;
            }
            // Handle negative values (-128 to -1): transition from black to blue
            else if (value < 0) {
                const intensity = Math.abs(value) / 128.0;
                b = 255 * intensity;
            }
            // Handle the midpoint (zero)
            else {
                b = 0;
            }
            return [r, g, b, alpha];
        }

        function renderSoup() {
            if (!lastColorIndices) return;

            const soupSize = lastColorIndices.length;
            if (soupWidth * soupHeight !== soupSize) {
                 console.error("Size mismatch");
                 return;
            }

            for (let i = 0; i < soupSize; i++) {
                const byteValue = lastColorIndices[i];
                const int8Value = byteValue > 127 ? byteValue - 256 : byteValue;
                const pixelIndex = i * 4;
                let color;

                if (viewMode === 'opcode') {
                    if (!opcodeData || opcodeData.length === 0) {
                        color = [128, 128, 128, 255]; // Default gray if no data
                    } else {
                        const NumOpcodes = opcodeData.length;
                        const colorIndex = ((int8Value % NumOpcodes) + NumOpcodes) % NumOpcodes;
                        color = opcodeData[colorIndex].color;
                    }
                } else { // heatmap
                    color = getHeatmapColor(int8Value);
                }

                imageDataBuffer[pixelIndex]     = color[0];
                imageDataBuffer[pixelIndex + 1] = color[1];
                imageDataBuffer[pixelIndex + 2] = color[2];
                imageDataBuffer[pixelIndex + 3] = color[3];
            }
            offscreenCtx.putImageData(imageData, 0, 0);
            requestAnimationFrame(draw);
        }

        // --- Data Display & Controls ---
        const genSpan = document.getElementById('gen');
        const stepsSpan = document.getElementById('steps');
        const entropySpan = document.getElementById('entropy');
        const jumpFailureProbabilitySlider = document.getElementById('jumpFailureProbability');
        const jumpFailureProbabilityValueSpan = document.getElementById('jumpFailureProbabilityValue');
        const opcodeLegendDiv = document.getElementById('opcode-legend');

        function generateOpcodeLegend() {
            opcodeLegendDiv.innerHTML = ''; // Clear existing legend
            if (!opcodeData || opcodeData.length === 0) return;
            opcodeData.forEach(opcode => {
                const color = opcode.color;
                const name = opcode.name;
                const colorBox = `<span style="display:inline-block; width:12px; height:12px; background-color:rgba(${color.join(',')}); border:1px solid #777; vertical-align:middle; margin-right:5px;"></span>`;
                const legendItem = document.createElement('div');
                legendItem.innerHTML = `${colorBox}${name}`;
                opcodeLegendDiv.appendChild(legendItem);
            });
        }

        // --- View State ---
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let soupWidth = 0;
        let soupHeight = 0;
        let isDragging = false; // New flag to detect dragging
        let highlightedIpPtr = -1; // Tracked IP pointer for highlighting
        let viewMode = 'opcode';
        let lastColorIndices = null;
        let isPaused = false;
        let soupTotalSize = 0;
        let soupPageSize = 0;
        let currentViewStartIndex = 0;

        // --- WebSocket Connection ---
        const socket = new WebSocket('ws://localhost:8080/ws');
        socket.binaryType = 'arraybuffer';

        let imageData;
        let imageDataBuffer;

        function draw() {
            if (!soupWidth) return;

            // Set canvas size to fill container
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            // --- Disable image smoothing for crisp pixels ---
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false; // For Safari
            ctx.mozImageSmoothingEnabled = false;    // For Firefox

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            ctx.drawImage(offscreenCanvas, 0, 0);

            // Highlight tracked IP
            if (highlightedIpPtr !== -1 && soupWidth > 0) {
                const relativePtr = highlightedIpPtr - currentViewStartIndex;
                if (relativePtr >= 0 && relativePtr < (soupWidth * soupHeight)) {
                    const pixelX = relativePtr % soupWidth;
                    const pixelY = Math.floor(relativePtr / soupWidth);

                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2 / zoom; // Adjust line width to scale with zoom
                    ctx.strokeRect(pixelX, pixelY, 1, 1); // Draw 1x1 rectangle, which will be scaled by context.zoom
                }
            }

            ctx.restore();
        }

        socket.onmessage = function(event) {
            if (typeof event.data === 'string') {
                const data = JSON.parse(event.data);
                if (data.type === 'instruction_set') {
                    opcodeNames = data.instructions;
                    soupTotalSize = data.soupSize;
                    // Combine names and colors
                    opcodeData = opcodeNames.map((name, index) => {
                        return {
                            name: name,
                            color: opcodeColors[index] || [128, 128, 128, 255] // Default gray
                        };
                    });
                    generateOpcodeLegend();
                    if (lastColorIndices) {
                        renderSoup();
                    }
                } else if (data.Generation !== undefined) {
                    // It's GenerationStats
                    genSpan.textContent = data.Generation;
                    stepsSpan.textContent = (data.StepsPerSecond).toLocaleString();
                    entropySpan.textContent = data.Entropy.toFixed(2);
                } else if (data.ID !== undefined) {
                    // It's an IP state update (SavableIP)
                    trackedIpIdSpan.textContent = data.ID;
                    trackedIpCurrentPtrSpan.textContent = "0x" + data.CurrentPtr.toString(16);

                    highlightedIpPtr = data.CurrentPtr; // Update highlighted IP pointer

                    // If follow IP is enabled, center the view on the IP
                    if (followIpCheckbox.checked && highlightedIpPtr !== -1 && soupWidth > 0) {
                        const localSoupPageSize = soupWidth * soupHeight;
                        const ipPageStartIndex = Math.floor(highlightedIpPtr / localSoupPageSize) * localSoupPageSize;

                        // Check if the IP has moved to a different page
                        if (ipPageStartIndex !== currentViewStartIndex) {
                            // Switch to the correct page
                            currentViewStartIndex = ipPageStartIndex;
                            sendViewStartIndex(currentViewStartIndex);
                            updatePageInfo();
                        }

                        // Calculate position relative to the current page
                        const relativePtr = highlightedIpPtr - currentViewStartIndex;
                        const pixelX = relativePtr % soupWidth;
                        const pixelY = Math.floor(relativePtr / soupWidth);

                        const targetZoom = 16; // A good zoom level to see the IP

                        // Calculate new offsets to center the IP
                        offsetX = (canvas.width / 2) - (pixelX * targetZoom);
                        offsetY = (canvas.height / 2) - (pixelY * targetZoom);
                        zoom = targetZoom;
                    }
                    // Always request a redraw to show the highlight, even if not following
                    requestAnimationFrame(draw);

                    let instructionName = "UNKNOWN";
                    let color = [128, 128, 128, 255]; // Default gray

                    if (opcodeData && opcodeData.length > 0) {
                        const instructionValue = data.CurrentInstruction;
                        const colorIndex = (instructionValue % opcodeData.length + opcodeData.length) % opcodeData.length;
                        const opcode = opcodeData[colorIndex];
                        instructionName = opcode.name;
                        color = opcode.color;
                    }


                    trackedIpInstructionSpan.innerHTML = ``; // Clear previous content
                    const colorBox = document.createElement('span');
                    colorBox.style.display = 'inline-block';
                    colorBox.style.width = '12px';
                    colorBox.style.height = '12px';
                    colorBox.style.backgroundColor = `rgba(${color.join(',')})`;
                    colorBox.style.border = '1px solid #777';
                    colorBox.style.verticalAlign = 'middle';
                    colorBox.style.marginRight = '5px';
                    trackedIpInstructionSpan.appendChild(colorBox);
                    trackedIpInstructionSpan.append(instructionName);

                    // Add to instruction history
                    const historyItem = document.createElement('div');
                    historyItem.textContent = `ID: ${data.ID}, Ptr: 0x${data.CurrentPtr.toString(16)}, Instr: ${instructionName}`;
                    instructionHistoryDiv.prepend(historyItem); // Add to the top
                    if (instructionHistoryDiv.children.length > 50) { // Limit history to 50 items
                        instructionHistoryDiv.removeChild(instructionHistoryDiv.lastChild);
                    }
                }
            } else if (event.data instanceof ArrayBuffer) {
                const colorIndices = new Uint8Array(event.data);
                lastColorIndices = colorIndices;
                const soupSize = colorIndices.length;
                const canvasSize = Math.sqrt(soupSize);

                if (!imageData || soupWidth !== canvasSize) {
                    soupWidth = canvasSize;
                    soupHeight = canvasSize;
                    soupPageSize = soupWidth * soupHeight;
                    offscreenCanvas.width = soupWidth;
                    offscreenCanvas.height = soupHeight;
                    imageData = offscreenCtx.createImageData(soupWidth, soupHeight);
                    imageDataBuffer = imageData.data;
                    // Center the initial view
                    offsetX = (canvasContainer.clientWidth - soupWidth * zoom) / 2;
                    offsetY = (canvasContainer.clientHeight - soupHeight * zoom) / 2;
                }
                updatePageInfo();
                renderSoup();
            }
        };

        // --- Event Listeners ---

        // Pan
        canvasContainer.addEventListener('mousedown', (e) => {
            isPanning = true;
            isDragging = false; // Assume not dragging initially
            canvasContainer.style.cursor = 'grabbing';
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvasContainer.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mouseleave', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) { // Consider it a drag if moved more than 5 pixels
                isDragging = true;
            }
            offsetX += dx;
            offsetY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(draw);
        });

        // Click to set IP pointer
        canvas.addEventListener('click', (e) => {
            if (isDragging) { // Don't set IP if it was a drag
                isDragging = false; // Reset for next click
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Convert canvas coordinates to soup coordinates
            const soupX = Math.floor((x - offsetX) / zoom);
            const soupY = Math.floor((y - offsetY) / zoom);

            // Calculate the absolute soup address
            const soupAddress = currentViewStartIndex + (soupY * soupWidth) + soupX;

            // Send the command to the server for IP ID 1
            const message = {
                type: "set_ip_ptr",
                id: 1, // Hardcoded for the first IP
                ptr: soupAddress
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        // Zoom
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Position of the mouse relative to the zoomed image
            const mouseXInImage = (mouseX - offsetX) / zoom;
            const mouseYInImage = (mouseY - offsetY) / zoom;

            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            const newZoom = zoom * zoomFactor;

            // Clamp zoom level
            const maxZoom = 32;
            const minZoom = canvasContainer.clientHeight / 1024; // Ensure it doesn't get smaller than the view
            zoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            // Adjust offset to keep the mouse position constant
            offsetX = mouseX - mouseXInImage * zoom;
            offsetY = mouseY - mouseYInImage * zoom;

            requestAnimationFrame(draw);
        });


        // Jump Failure Probability Slider
        jumpFailureProbabilitySlider.addEventListener('input', (e) => {
            const probability = parseInt(e.target.value);
            jumpFailureProbabilityValueSpan.textContent = probability;
            const message = {
                type: "set_jump_failure_probability",
                value: probability
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        // --- Command Buttons ---
        const playPauseButton = document.getElementById('playPauseButton');
        const stepButton = document.getElementById('stepButton');
        const followIpCheckbox = document.getElementById('followIpCheckbox');

        const prevPageButton = document.getElementById('prevPage');
        const nextPageButton = document.getElementById('nextPage');

        const bit32AddressingCheckbox = document.getElementById('32BitAddressing');
        const relativeAddressingCheckbox = document.getElementById('relativeAddressing');

        const rightPanel = document.getElementById('right-panel');
        const trackedIpIdSpan = document.getElementById('trackedIpId');
        const trackedIpCurrentPtrSpan = document.getElementById('trackedIpCurrentPtr');
        const trackedIpInstructionSpan = document.getElementById('trackedIpInstruction');
        const instructionHistoryDiv = document.getElementById('instructionHistory');
        const pageInfoSpan = document.getElementById('pageInfo');

        function showRightPanel() {
            rightPanel.style.display = 'block';
        }

        function hideRightPanel() {
            rightPanel.style.display = 'none';
        }

        function sendCommand(command) {
            const message = {
                type: "command",
                command: command
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendViewStartIndex(index) {
            const message = {
                type: "set_view_start_index",
                value: index
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendAddressingMode(type, enabled) {
            const message = {
                type: type,
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendTrackingEnabled(enabled) {
            const message = {
                type: "set_tracking_enabled",
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function updatePageInfo() {
            if (!soupPageSize || !soupTotalSize) return;
            const currentPage = (currentViewStartIndex / soupPageSize) + 1;
            const totalPages = Math.ceil(soupTotalSize / soupPageSize);
            pageInfoSpan.textContent = `Page ${currentPage} / ${totalPages}`;

            prevPageButton.disabled = (currentPage <= 1);
            nextPageButton.disabled = (currentPage >= totalPages);
        }

        playPauseButton.addEventListener('click', () => {
            if (isPaused) {
                sendCommand('resume');
                hideRightPanel();
                sendTrackingEnabled(false);
                highlightedIpPtr = -1;
                playPauseButton.textContent = 'Pause';
            } else {
                sendCommand('pause');
                showRightPanel();
                sendTrackingEnabled(true);
                playPauseButton.textContent = 'Play';
            }
            isPaused = !isPaused;
        });

        stepButton.addEventListener('click', () => sendCommand('step'));

        prevPageButton.addEventListener('click', () => {
            if (currentViewStartIndex > 0) {
                currentViewStartIndex -= soupPageSize;
                sendViewStartIndex(currentViewStartIndex);
                updatePageInfo();
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (!soupTotalSize || !soupPageSize) return;
            const totalPages = Math.ceil(soupTotalSize / soupPageSize);
            const maxStartIndex = (totalPages - 1) * soupPageSize;
            if (currentViewStartIndex < maxStartIndex) {
                currentViewStartIndex += soupPageSize;
                sendViewStartIndex(currentViewStartIndex);
                updatePageInfo();
            }
        });

        bit32AddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_32_bit_addressing', event.target.checked);
        });

        relativeAddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_relative_addressing', event.target.checked);
        });

        const viewModeRadios = document.querySelectorAll('input[name="viewMode"]');
        viewModeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                viewMode = event.target.value;
                if (viewMode === 'opcode') {
                    opcodeLegendDiv.style.display = 'block';
                } else {
                    opcodeLegendDiv.style.display = 'none';
                }
                renderSoup(); // Redraw with the new mode
            });
        });

        // Resize Observer
        new ResizeObserver(draw).observe(canvasContainer);

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && rightPanel.style.display === 'block') {
                stepButton.click();
            }
        });

        socket.onopen = function(event) {
            console.log("WebSocket connection established.");
            // Set initial jump failure probability on the server and UI
            const initialProbability = 50; // Default value
            jumpFailureProbabilitySlider.value = initialProbability;
            jumpFailureProbabilityValueSpan.textContent = initialProbability;
            jumpFailureProbabilitySlider.dispatchEvent(new Event('input'));
        };

        socket.onerror = function(error) {
            console.error("WebSocket Error: ", error);
        };
    </script>
</body>
</html>