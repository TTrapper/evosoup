<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EvoSoup Visualization</title>
    <style>
        body { font-family: monospace; background-color: #2e2e2e; color: #d3d3d3; margin: 0; overflow: hidden; }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        label { display: block; margin-bottom: 5px; }
        #controls-buttons button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            width: 80px; /* Give button a fixed width */
        }
        #controls-buttons button:hover {
            background-color: #777;
        }
        #paging-controls {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        #paging-controls button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #paging-controls button:hover {
            background-color: #777;
        }
        #paging-controls button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }
        #paging-controls span {
            margin: 0 10px;
            font-weight: bold;
        }
        #addressing-modes label {
            margin-right: 10px;
        }

        #trackedIpState p {
            margin: 5px 0;
        }
        #right-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px; /* Adjust as needed */
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            color: #d3d3d3;
        }
        #right-panel h2,
        #right-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #eee;
        }
        #right-panel p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="soupCanvas"></canvas>
    </div>
    <div id="controls">
        <h1>EvoSoup</h1>
        <p>Generation: <span id="gen">0</span></p>
        <p>Steps/sec: <span id="steps">0</span></p>
        <p>Entropy: <span id="entropy">0.00</span></p>
        <label for="cosmicRayRate">Cosmic Ray Rate: <span id="cosmicRayRateValue">50</span>%</label>
        <input type="range" id="cosmicRayRate" min="0" max="1000" step="1" value="0">
        <div id="controls-buttons">
            <button id="playPauseButton">Pause</button>
        </div>
        <div id="paging-controls">
            <button id="prevPage">&lt;</button>
            <span id="pageInfo">Page ? / ?</span>
            <button id="nextPage">&gt;</button>
        </div>
        <div id="addressing-modes">
            <label><input type="checkbox" id="32BitAddressing"> 32-bit Addressing</label>
            <label><input type="checkbox" id="relativeAddressing" checked> Relative Addressing</label>
        </div>
        <div id="view-mode-controls">
            <label><input type="radio" name="viewMode" value="colormap" checked> Colormap</label>
            <label><input type="radio" name="viewMode" value="heatmap"> Heatmap</label>
        </div>
        <div id="opcode-legend"></div>
    </div>

    <div id="right-panel" style="display: none;">
        <h2>Tracked IP State</h2>
        <div id="trackedIpState">
            <p>ID: <span id="trackedIpId">-</span></p>
            <p>Position: <span id="trackedIpPosition">-</span></p>
            <p>Instruction: <span id="trackedIpInstruction">-</span></p>
            <button id="stepButton">Step</button>
            <label><input type="checkbox" id="followIpCheckbox" checked> Follow IP</label>
        </div>
        <h3>Instruction History</h3>
        <div id="instructionHistory" style="max-height: 200px; overflow-y: scroll; border: 1px solid #555; padding: 5px;"></div>
    </div>

    <script>
        // --- Canvas and WebSocket Setup ---
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('soupCanvas');
        const ctx = canvas.getContext('2d');

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), 255];
        }

        let instructionInfo = {};
        let colorLookup = new Array(256).fill([46, 46, 46, 255]);

        function generateColormap() {
            if (!instructionInfo.opcodes) return;

            const opcodes = instructionInfo.opcodes;
            const aluOpBits = instructionInfo.alu_op_bits;
            const numOpcodes = opcodes.length;
            const mask = (0xFF << (8 - aluOpBits)) & 0xFF;
            const opToColor = {};

            // 1. Generate a base color for each opcode type
            opcodes.forEach((op, index) => {
                const hue = (2/3) - (index / (numOpcodes - 1)) * (2/3);
                op.color = hslToRgb(hue, 0.9, 0.6);
                opToColor[op.value << (8 - aluOpBits)] = op.color;
            });

            // 2. Create the 256-entry lookup table
            const newColorLookup = new Array(256);
            for (let i = 0; i < 256; i++) {
                const opValue = i & mask;
                newColorLookup[i] = opToColor[opValue] || [46, 46, 46, 255];
            }
            colorLookup = newColorLookup;
        }

        function getHeatmapColor(value) {
            let r = 0, g = 0, b = 0;
            const alpha = 255;
            if (value > 0) {
                r = 255 * (value / 127.0);
            } else if (value < 0) {
                b = 255 * (Math.abs(value) / 128.0);
            }
            return [r, g, b, alpha];
        }

        function renderSoup() {
            if (!lastColorIndices) return;

            const soupSize = lastColorIndices.length;
            if (soupWidth * soupHeight !== soupSize) {
                 console.error("Size mismatch");
                 return;
            }

            for (let i = 0; i < soupSize; i++) {
                const byteValue = lastColorIndices[i];
                const int8Value = byteValue > 127 ? byteValue - 256 : byteValue;
                const pixelIndex = i * 4;
                let color;

                if (viewMode === 'colormap') {
                    color = colorLookup[byteValue];
                } else { // heatmap
                    color = getHeatmapColor(int8Value);
                }

                imageDataBuffer[pixelIndex]     = color[0];
                imageDataBuffer[pixelIndex + 1] = color[1];
                imageDataBuffer[pixelIndex + 2] = color[2];
                imageDataBuffer[pixelIndex + 3] = color[3];
            }
            offscreenCtx.putImageData(imageData, 0, 0);
            requestAnimationFrame(draw);
        }

        // --- Data Display & Controls ---
        const genSpan = document.getElementById('gen');
        const stepsSpan = document.getElementById('steps');
        const entropySpan = document.getElementById('entropy');
        const cosmicRayRateSlider = document.getElementById('cosmicRayRate');
        const cosmicRayRateValueSpan = document.getElementById('cosmicRayRateValue');
        const opcodeLegendDiv = document.getElementById('opcode-legend');

        function formatProbability(p) {
            p = p * 100
            if (p === 0) return "0.00";
            if (p < 0.001) return p.toExponential(2);
            return p.toFixed(4);
        }

        function generateLegend() {
            opcodeLegendDiv.innerHTML = ''; // Clear existing legend
            if (!instructionInfo.opcodes) return;
            instructionInfo.opcodes.forEach(op => {
                const color = op.color;
                const name = op.name;
                const colorBox = `<span style="display:inline-block; width:12px; height:12px; background-color:rgba(${color.join(',')}); border:1px solid #777; vertical-align:middle; margin-right:5px;"></span>`;
                const legendItem = document.createElement('div');
                legendItem.innerHTML = `${colorBox}${name}`;
                opcodeLegendDiv.appendChild(legendItem);
            });
        }

        // --- View State ---
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let soupWidth = 0;
        let soupHeight = 0;
        let isDragging = false;
        let highlightedIpPtr = -1;
        let viewMode = 'colormap';
        let lastColorIndices = null;
        let isPaused = false;
        let soupTotalSize = 1024*1024;
        let soupPageSize = 0;
        let currentViewStartIndex = 0;

        // --- WebSocket Connection ---
        const socket = new WebSocket('ws://localhost:8080/ws');
        socket.binaryType = 'arraybuffer';

        let imageData;
        let imageDataBuffer;

        function draw() {
            if (!soupWidth) return;

            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            ctx.drawImage(offscreenCanvas, 0, 0);

            if (highlightedIpPtr !== -1 && soupWidth > 0) {
                const relativePtr = highlightedIpPtr - currentViewStartIndex;
                if (relativePtr >= 0 && relativePtr < (soupWidth * soupHeight)) {
                    const pixelX = relativePtr % soupWidth;
                    const pixelY = Math.floor(relativePtr / soupWidth);

                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2 / zoom;
                    ctx.strokeRect(pixelX, pixelY, 1, 1);
                }
            }

            ctx.restore();
        }

        socket.onmessage = function(event) {
            if (typeof event.data === 'string') {
                const data = JSON.parse(event.data);
                if (data.type === 'instruction_info') {
                    instructionInfo = data;
                    generateColormap();
                    generateLegend();
                    if (lastColorIndices) {
                        renderSoup();
                    }
                } else if (data.type === 'sim_params') {
                    const probability = data.cosmicRayRate;
                    soupTotalSize = data.soupSize;

                    const maxSliderValue = 1000;
                    let sliderValue = 0;
                    if (probability > 0) {
                        sliderValue = maxSliderValue * Math.sqrt(probability);
                    }

                    cosmicRayRateSlider.value = sliderValue;
                    cosmicRayRateValueSpan.textContent = formatProbability(probability);
                } else if (data.Generation !== undefined) {
                    genSpan.textContent = data.Generation;
                    stepsSpan.textContent = (data.StepsPerSecond).toLocaleString();
                    entropySpan.textContent = data.Entropy.toFixed(2);
                } else if (data.ID !== undefined) {
                    trackedIpIdSpan.textContent = data.ID;
                    const currentPtr = data.Y * soupWidth + data.X;
                    trackedIpPositionSpan.textContent = `(${data.X}, ${data.Y})`;

                    highlightedIpPtr = currentPtr;

                    if (followIpCheckbox.checked && highlightedIpPtr !== -1 && soupWidth > 0) {
                        const localSoupPageSize = soupWidth * soupHeight;
                        const ipPageStartIndex = Math.floor(highlightedIpPtr / localSoupPageSize) * localSoupPageSize;

                        if (ipPageStartIndex !== currentViewStartIndex) {
                            currentViewStartIndex = ipPageStartIndex;
                            sendViewStartIndex(currentViewStartIndex);
                            updatePageInfo();
                        }

                        const relativePtr = highlightedIpPtr - currentViewStartIndex;
                        const pixelX = relativePtr % soupWidth;
                        const pixelY = Math.floor(relativePtr / soupWidth);
                        const targetZoom = 16;

                        offsetX = (canvas.width / 2) - (pixelX * targetZoom);
                        offsetY = (canvas.height / 2) - (pixelY * targetZoom);
                        zoom = targetZoom;
                    }
                    requestAnimationFrame(draw);

                    const instructionValue = data.CurrentInstruction;
                    const instructionHex = "0x" + instructionValue.toString(16).padStart(2, '0');
                    trackedIpInstructionSpan.textContent = instructionHex;

                    const historyItem = document.createElement('div');
                    historyItem.textContent = `ID: ${data.ID}, Pos: (${data.X},${data.Y}), Instr: ${instructionHex}`;
                    instructionHistoryDiv.prepend(historyItem);
                    if (instructionHistoryDiv.children.length > 50) {
                        instructionHistoryDiv.removeChild(instructionHistoryDiv.lastChild);
                    }
                }
            } else if (event.data instanceof ArrayBuffer) {
                const colorIndices = new Uint8Array(event.data);
                lastColorIndices = colorIndices;
                const soupSize = colorIndices.length;
                const canvasSize = Math.sqrt(soupSize);

                if (!imageData || soupWidth !== canvasSize) {
                    soupWidth = canvasSize;
                    soupHeight = canvasSize;
                    soupPageSize = soupWidth * soupHeight;
                    offscreenCanvas.width = soupWidth;
                    offscreenCanvas.height = soupHeight;
                    imageData = offscreenCtx.createImageData(soupWidth, soupHeight);
                    imageDataBuffer = imageData.data;
                    offsetX = (canvasContainer.clientWidth - soupWidth * zoom) / 2;
                    offsetY = (canvasContainer.clientHeight - soupHeight * zoom) / 2;
                }
                updatePageInfo();
                renderSoup();
            }
        };

        // --- Event Listeners ---

        canvasContainer.addEventListener('mousedown', (e) => {
            isPanning = true;
            isDragging = false;
            canvasContainer.style.cursor = 'grabbing';
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvasContainer.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mouseleave', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                isDragging = true;
            }
            offsetX += dx;
            offsetY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(draw);
        });

        canvas.addEventListener('click', (e) => {
            if (isDragging) {
                isDragging = false;
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const soupX = Math.floor((x - offsetX) / zoom);
            const soupY = Math.floor((y - offsetY) / zoom);

            const soupAddress = currentViewStartIndex + (soupY * soupWidth) + soupX;

            const message = {
                type: "set_ip_ptr",
                id: 1,
                ptr: soupAddress
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const mouseXInImage = (mouseX - offsetX) / zoom;
            const mouseYInImage = (mouseY - offsetY) / zoom;

            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            const newZoom = zoom * zoomFactor;

            const maxZoom = 32;
            const minZoom = canvasContainer.clientHeight / 1024;
            zoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            offsetX = mouseX - mouseXInImage * zoom;
            offsetY = mouseY - mouseYInImage * zoom;

            requestAnimationFrame(draw);
        });

        cosmicRayRateSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            let probability = 0;

            const maxSliderValue = 1000;
            if (sliderValue > 0) {
                probability = Math.pow(sliderValue / maxSliderValue, 2);
            }

            cosmicRayRateValueSpan.textContent = formatProbability(probability);
            const message = {
                type: "set_cosmic_ray_rate",
                value: probability
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        // --- Command Buttons ---
        const playPauseButton = document.getElementById('playPauseButton');
        const stepButton = document.getElementById('stepButton');
        const followIpCheckbox = document.getElementById('followIpCheckbox');

        const prevPageButton = document.getElementById('prevPage');
        const nextPageButton = document.getElementById('nextPage');

        const bit32AddressingCheckbox = document.getElementById('32BitAddressing');
        const relativeAddressingCheckbox = document.getElementById('relativeAddressing');

        const rightPanel = document.getElementById('right-panel');
        const trackedIpIdSpan = document.getElementById('trackedIpId');
        const trackedIpPositionSpan = document.getElementById('trackedIpPosition');
        const trackedIpInstructionSpan = document.getElementById('trackedIpInstruction');
        const instructionHistoryDiv = document.getElementById('instructionHistory');
        const pageInfoSpan = document.getElementById('pageInfo');

        function showRightPanel() {
            rightPanel.style.display = 'block';
        }

        function hideRightPanel() {
            rightPanel.style.display = 'none';
        }

        function sendCommand(command) {
            const message = {
                type: "command",
                command: command
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendViewStartIndex(index) {
            const message = {
                type: "set_view_start_index",
                value: index
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendAddressingMode(type, enabled) {
            const message = {
                type: type,
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendTrackingEnabled(enabled) {
            const message = {
                type: "set_tracking_enabled",
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function updatePageInfo() {
            if (!soupPageSize || !soupTotalSize) return;
            const currentPage = (currentViewStartIndex / soupPageSize) + 1;
            const totalPages = Math.ceil(soupTotalSize / soupPageSize);
            pageInfoSpan.textContent = `Page ${currentPage} / ${totalPages}`;

            prevPageButton.disabled = (currentPage <= 1);
            nextPageButton.disabled = (currentPage >= totalPages);
        }

        playPauseButton.addEventListener('click', () => {
            if (isPaused) {
                sendCommand('resume');
                hideRightPanel();
                sendTrackingEnabled(false);
                highlightedIpPtr = -1;
                playPauseButton.textContent = 'Pause';
            } else {
                sendCommand('pause');
                showRightPanel();
                sendTrackingEnabled(true);
                playPauseButton.textContent = 'Play';
            }
            isPaused = !isPaused;
        });

        stepButton.addEventListener('click', () => sendCommand('step'));

        prevPageButton.addEventListener('click', () => {
            if (currentViewStartIndex > 0) {
                currentViewStartIndex -= soupPageSize;
                sendViewStartIndex(currentViewStartIndex);
                updatePageInfo();
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (!soupTotalSize || !soupPageSize) return;
            const totalPages = Math.ceil(soupTotalSize / soupPageSize);
            const maxStartIndex = (totalPages - 1) * soupPageSize;
            if (currentViewStartIndex < maxStartIndex) {
                currentViewStartIndex += soupPageSize;
                sendViewStartIndex(currentViewStartIndex);
                updatePageInfo();
            }
        });

        bit32AddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_32_bit_addressing', event.target.checked);
        });

        relativeAddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_relative_addressing', event.target.checked);
        });

        const viewModeRadios = document.querySelectorAll('input[name="viewMode"]');
        viewModeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                viewMode = event.target.value;
                if (viewMode === 'colormap') {
                    opcodeLegendDiv.style.display = 'block';
                } else {
                    opcodeLegendDiv.style.display = 'none';
                }
                renderSoup();
            });
        });

        // Initial setup
        new ResizeObserver(draw).observe(canvasContainer);

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && rightPanel.style.display === 'block') {
                stepButton.click();
            }
        });

        socket.onopen = function(event) {
            console.log("WebSocket connection established.");
        };

        socket.onerror = function(error) {
            console.error("WebSocket Error: ", error);
        };
    </script>
</body>
</html>