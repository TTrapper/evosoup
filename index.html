<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EvoSoup Visualization</title>
    <style>
        body { font-family: monospace; background-color: #2e2e2e; color: #d3d3d3; margin: 0; overflow: hidden; }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        label { display: block; margin-bottom: 5px; }
        #controls-buttons button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            width: 80px; /* Give button a fixed width */
        }
        #controls-buttons button:hover {
            background-color: #777;
        }
        #paging-controls {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        #paging-controls button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #paging-controls button:hover {
            background-color: #777;
        }
        #paging-controls button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }
        #paging-controls span {
            margin: 0 10px;
            font-weight: bold;
        }
        #addressing-modes label {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="soupCanvas"></canvas>
    </div>
    <div id="controls">
        <h1>EvoSoup</h1>
        <p>Time: <span id="gen">00:00:00</span></p>
        <p>Steps/sec: <span id="steps">0</span></p>
        <p>Entropy: <span id="entropy">0.00</span></p>
        <label for="cosmicRayRate">Cosmic Ray Rate: <span id="cosmicRayRateValue">50</span>%</label>
        <input type="range" id="cosmicRayRate" min="0" max="1000" step="1" value="0">
        <div id="controls-buttons">
            <button id="playPauseButton">Pause</button>
        </div>
        <div id="paging-controls" style="display: grid; grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(3, 40px); gap: 5px; justify-content: center; align-items: center; width: 130px;">
            <div style="grid-column: 2; grid-row: 1;"><button id="pageUp">▲</button></div>
            <div style="grid-column: 1; grid-row: 2;"><button id="pageLeft">◄</button></div>
            <div style="grid-column: 3; grid-row: 2;"><button id="pageRight">►</button></div>
            <div style="grid-column: 2; grid-row: 3;"><button id="pageDown">▼</button></div>
        </div>
        <div id="addressing-modes">
            <label><input type="checkbox" id="32BitAddressing"> 32-bit Addressing</label>
            <label><input type="checkbox" id="relativeAddressing" checked> Relative Addressing</label>
        </div>
        <div id="view-mode-controls">
            <label><input type="radio" name="viewMode" value="colormap" checked> Colormap</label>
            <label><input type="radio" name="viewMode" value="heatmap"> Heatmap</label>
            <label><input type="checkbox" id="showIpsCheckbox"> Show IPs</label>
        </div>
        <div id="opcode-legend"></div>
    </div>

    <script>
        // --- Canvas and WebSocket Setup ---
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('soupCanvas');
        const ctx = canvas.getContext('2d');

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), 255];
        }

        let instructionInfo = {};
        let colorLookup = new Array(256).fill([46, 46, 46, 255]);

        function generateColormap() {
            if (!instructionInfo.opcodes) return;

            const opcodes = instructionInfo.opcodes;
            const aluOpBits = instructionInfo.alu_op_bits;
            const numOpcodes = opcodes.length;
            const mask = (0xFF << (8 - aluOpBits)) & 0xFF;
            const opToHue = {};

            // 1. Generate a base hue for each opcode type
            opcodes.forEach((op, index) => {
                const hue = (2/3) - (index / (numOpcodes - 1)) * (2/3);
                // Keep op.color for the legend, representing the base color
                op.color = hslToRgb(hue, 0.9, 0.6);
                opToHue[op.value << (8 - aluOpBits)] = hue;
            });

            // 2. Create the 256-entry lookup table with shading
            const newColorLookup = new Array(256);
            const numShadingBits = 8 - aluOpBits;
            const maxShadingValue = (1 << numShadingBits) - 1;

            for (let i = 0; i < 256; i++) {
                const opValue = i & mask;
                const hue = opToHue[opValue];

                if (hue === undefined) {
                    newColorLookup[i] = [46, 46, 46, 255]; // Default color for unused bytes
                } else {
                    const shadingVariant = i & maxShadingValue;
                    // Vary lightness to create shades for instruction variants
                    const minLightness = 0.4;
                    const maxLightness = 0.8;
                    const lightnessRange = maxLightness - minLightness;

                    let lightness;
                    if (maxShadingValue > 0) {
                        lightness = minLightness + (shadingVariant / maxShadingValue) * lightnessRange;
                    } else {
                        lightness = 0.6; // Base lightness if no shading bits
                    }

                    newColorLookup[i] = hslToRgb(hue, 0.9, lightness);
                }
            }
            colorLookup = newColorLookup;
        }

        function getHeatmapColor(value) {
            let r = 0, g = 0, b = 0;
            const alpha = 255;
            if (value > 0) {
                r = 255 * (value / 127.0);
            } else if (value < 0) {
                b = 255 * (Math.abs(value) / 128.0);
            }
            return [r, g, b, alpha];
        }

        function renderSoup() {
            if (!lastColorIndices) return;

            const soupSize = lastColorIndices.length;
            if (soupWidth * soupHeight !== soupSize) {
                 console.error("Size mismatch");
                 return;
            }

            for (let i = 0; i < soupSize; i++) {
                const byteValue = lastColorIndices[i];
                const int8Value = byteValue > 127 ? byteValue - 256 : byteValue;
                const pixelIndex = i * 4;
                let color;

                if (viewMode === 'colormap') {
                    color = colorLookup[byteValue];
                } else { // heatmap
                    color = getHeatmapColor(int8Value);
                }

                imageDataBuffer[pixelIndex]     = color[0];
                imageDataBuffer[pixelIndex + 1] = color[1];
                imageDataBuffer[pixelIndex + 2] = color[2];
                imageDataBuffer[pixelIndex + 3] = color[3];
            }
            offscreenCtx.putImageData(imageData, 0, 0);
            requestAnimationFrame(draw);
        }

        // --- Data Display & Controls ---
        const genSpan = document.getElementById('gen');
        const stepsSpan = document.getElementById('steps');
        const entropySpan = document.getElementById('entropy');
        const cosmicRayRateSlider = document.getElementById('cosmicRayRate');
        const cosmicRayRateValueSpan = document.getElementById('cosmicRayRateValue');
        const opcodeLegendDiv = document.getElementById('opcode-legend');

        function formatProbability(p) {
            p = p * 100
            if (p === 0) return "0.00";
            if (p < 0.001) return p.toExponential(2);
            return p.toFixed(4);
        }

        function generateLegend() {
            opcodeLegendDiv.innerHTML = ''; // Clear existing legend
            if (!instructionInfo.opcodes) return;
            instructionInfo.opcodes.forEach(op => {
                const color = op.color;
                const name = op.name;
                const colorBox = `<span style="display:inline-block; width:12px; height:12px; background-color:rgba(${color.join(',')}); border:1px solid #777; vertical-align:middle; margin-right:5px;"></span>`;
                const legendItem = document.createElement('div');
                legendItem.innerHTML = `${colorBox}${name}`;
                opcodeLegendDiv.appendChild(legendItem);
            });
        }

        // --- View State ---
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let soupWidth = 0;
        let soupHeight = 0;
        let isDragging = false;
        let ipLocations = [];
        let viewMode = 'colormap';
        let lastColorIndices = null;
        let isPaused = false;
        let soupTotalSize = 0;
        let soupPageSize = 0;
        let currentViewStartIndex = 0;
        let soupGridDim = 0;
        let currentPageX = 0;
        let currentPageY = 0;

        // --- WebSocket Connection ---
        const socket = new WebSocket('ws://localhost:8080/ws');
        socket.binaryType = 'arraybuffer';

        let imageData;
        let imageDataBuffer;

        function draw() {
            if (!soupWidth) return;

            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            ctx.drawImage(offscreenCanvas, 0, 0);

            const showIpsCheckbox = document.getElementById('showIpsCheckbox');
            if (showIpsCheckbox.checked && ipLocations && ipLocations.length > 0) {
                for (const ip of ipLocations) {
                    const localX = ip.x % soupWidth;
                    const localY = ip.y % soupHeight;

                    if (viewMode === 'colormap') {
                        // White outline with black border for max contrast, drawn inside the pixel
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2 / zoom;
                        ctx.strokeRect(localX + 0.1, localY + 0.1, 0.8, 0.8);
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / zoom;
                        ctx.strokeRect(localX + 0.1, localY + 0.1, 0.8, 0.8);
                    } else { // heatmap
                        ctx.strokeStyle = 'yellow';
                        ctx.lineWidth = 1 / zoom;
                        ctx.strokeRect(localX, localY, 1, 1);
                    }
                }
            }

            ctx.restore();
        }

        socket.onmessage = function(event) {
            if (typeof event.data === 'string') {
                const data = JSON.parse(event.data);
                if (data.type === 'instruction_info') {
                    instructionInfo = data;
                    generateColormap();
                    generateLegend();
                    if (lastColorIndices) {
                        renderSoup();
                    }
                } else if (data.type === 'sim_params') {
                    const probability = data.cosmicRayRate;
                    soupTotalSize = data.soupSize;
                    soupGridDim = data.soupGridDim;

                    const maxSliderValue = 1000;
                    let sliderValue = 0;
                    if (probability > 0) {
                        sliderValue = maxSliderValue * Math.sqrt(probability);
                    }

                    cosmicRayRateSlider.value = sliderValue;
                    cosmicRayRateValueSpan.textContent = formatProbability(probability);
                } else if (data.type === 'ip_locations') {
                    ipLocations = data.locations;
                    requestAnimationFrame(draw);
                } else if (data.Generation !== undefined) {
                    genSpan.textContent = data.Generation;
                    stepsSpan.textContent = (data.StepsPerSecond).toLocaleString();
                    entropySpan.textContent = data.Entropy.toFixed(2);
                }
            } else if (event.data instanceof ArrayBuffer) {
                const colorIndices = new Uint8Array(event.data);
                lastColorIndices = colorIndices;
                const soupSize = colorIndices.length;
                const canvasSize = Math.sqrt(soupSize);

                if (!imageData || soupWidth !== canvasSize) {
                    soupWidth = canvasSize;
                    soupHeight = canvasSize;
                    soupPageSize = soupWidth * soupHeight;
                    offscreenCanvas.width = soupWidth;
                    offscreenCanvas.height = soupHeight;
                    imageData = offscreenCtx.createImageData(soupWidth, soupHeight);
                    imageDataBuffer = imageData.data;
                    offsetX = (canvasContainer.clientWidth - soupWidth * zoom) / 2;
                    offsetY = (canvasContainer.clientHeight - soupHeight * zoom) / 2;
                }
                renderSoup();
            }
        };

        // --- Event Listeners ---

        canvasContainer.addEventListener('mousedown', (e) => {
            isPanning = true;
            isDragging = false;
            canvasContainer.style.cursor = 'grabbing';
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvasContainer.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mouseleave', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                isDragging = true;
            }
            offsetX += dx;
            offsetY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(draw);
        });

        canvas.addEventListener('click', (e) => {
            if (isDragging) {
                isDragging = false;
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const viewX = Math.floor((x - offsetX) / zoom);
            const viewY = Math.floor((y - offsetY) / zoom);

            const soupX = currentPageX * soupWidth + viewX;
            const soupY = currentPageY * soupHeight + viewY;

            const totalSoupWidth = soupWidth * soupGridDim;
            const soupAddress = soupY * totalSoupWidth + soupX;

            const message = {
                type: "set_ip_ptr",
                id: 1,
                ptr: soupAddress
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const mouseXInImage = (mouseX - offsetX) / zoom;
            const mouseYInImage = (mouseY - offsetY) / zoom;

            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            const newZoom = zoom * zoomFactor;

            const maxZoom = 32;
            const minZoom = canvasContainer.clientHeight / 1024;
            zoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            offsetX = mouseX - mouseXInImage * zoom;
            offsetY = mouseY - mouseYInImage * zoom;

            requestAnimationFrame(draw);
        });

        cosmicRayRateSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            let probability = 0;

            const maxSliderValue = 1000;
            if (sliderValue > 0) {
                probability = Math.pow(sliderValue / maxSliderValue, 2);
            }

            cosmicRayRateValueSpan.textContent = formatProbability(probability);
            const message = {
                type: "set_cosmic_ray_rate",
                value: probability
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        // --- Command Buttons ---
        const playPauseButton = document.getElementById('playPauseButton');

        const pageUpButton = document.getElementById('pageUp');
        const pageDownButton = document.getElementById('pageDown');
        const pageLeftButton = document.getElementById('pageLeft');
        const pageRightButton = document.getElementById('pageRight');

        const bit32AddressingCheckbox = document.getElementById('32BitAddressing');
        const relativeAddressingCheckbox = document.getElementById('relativeAddressing');

        function sendCommand(command) {
            const message = {
                type: "command",
                command: command
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendViewStartIndex(index) {
            const message = {
                type: "set_view_start_index",
                value: index
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendAddressingMode(type, enabled) {
            const message = {
                type: type,
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        playPauseButton.addEventListener('click', () => {
            if (isPaused) {
                sendCommand('resume');
                playPauseButton.textContent = 'Pause';
            } else {
                sendCommand('pause');
                playPauseButton.textContent = 'Play';
            }
            isPaused = !isPaused;
        });

        function updateView() {
            if (!soupGridDim || !soupPageSize) return;

            const totalSoupWidth = soupGridDim * soupWidth;
            const startY = currentPageY * soupHeight;
            const startX = currentPageX * soupWidth;

            currentViewStartIndex = startY * totalSoupWidth + startX;

            sendViewStartIndex(currentViewStartIndex);
        }

        pageUpButton.addEventListener('click', () => {
            currentPageY = (currentPageY - 1 + soupGridDim) % soupGridDim;
            updateView();
        });

        pageDownButton.addEventListener('click', () => {
            currentPageY = (currentPageY + 1) % soupGridDim;
            updateView();
        });

        pageLeftButton.addEventListener('click', () => {
            currentPageX = (currentPageX - 1 + soupGridDim) % soupGridDim;
            updateView();
        });

        pageRightButton.addEventListener('click', () => {
            currentPageX = (currentPageX + 1) % soupGridDim;
            updateView();
        });

        bit32AddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_32_bit_addressing', event.target.checked);
        });

        relativeAddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_relative_addressing', event.target.checked);
        });

        const viewModeRadios = document.querySelectorAll('input[name="viewMode"]');
        viewModeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                viewMode = event.target.value;
                if (viewMode === 'colormap') {
                    opcodeLegendDiv.style.display = 'block';
                } else {
                    opcodeLegendDiv.style.display = 'none';
                }
                renderSoup();
            });
        });

        // Initial setup
        new ResizeObserver(draw).observe(canvasContainer);

        socket.onopen = function(event) {
            console.log("WebSocket connection established.");
        };

        socket.onerror = function(error) {
            console.error("WebSocket Error: ", error);
        };
    </script>
</body>
</html>
