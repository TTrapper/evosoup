<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EvoSoup Visualization</title>
    <style>
        body { font-family: monospace; background-color: #2e2e2e; color: #d3d3d3; margin: 0; overflow: hidden; }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        label { display: block; margin-bottom: 5px; }
        #controls-buttons button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #controls-buttons button:hover {
            background-color: #777;
        }
        #paging-buttons button {
            margin-right: 5px;
            padding: 8px 12px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #paging-buttons button:hover {
            background-color: #777;
        }
        #addressing-modes label {
            margin-right: 10px;
        }

        #trackedIpState p {
            margin: 5px 0;
        }
        #right-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px; /* Adjust as needed */
            background-color: rgba(46, 46, 46, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            color: #d3d3d3;
        }
        #right-panel h2,
        #right-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #eee;
        }
        #right-panel p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="soupCanvas"></canvas>
    </div>
    <div id="controls">
        <h1>EvoSoup</h1>
        <p>Generation: <span id="gen">0</span></p>
        <p>Steps/sec: <span id="steps">0</span></p>
        <p>Entropy: <span id="entropy">0.00</span></p>
        <label for="jumpRate">Jump Interval (Î¼s): <span id="jumpRateValue">1000</span></label>
        <input type="range" id="jumpRate" min="0" max="100" step="1" value="50">
        <div id="controls-buttons">
            <button id="pauseButton">Pause</button>
            <button id="resumeButton">Resume</button>
        </div>
        <div id="paging-buttons">
            <button id="prevPage">Previous Page</button>
            <button id="nextPage">Next Page</button>
        </div>
        <div id="addressing-modes">
            <label><input type="checkbox" id="32BitAddressing"> 32-bit Addressing</label>
            <label><input type="checkbox" id="relativeAddressing" checked> Relative Addressing</label>
        </div>
        <div id="opcode-legend"></div>
    </div>

    <div id="right-panel" style="display: none;">
        <h2>Tracked IP State</h2>
        <div id="trackedIpState">
            <p>ID: <span id="trackedIpId">-</span></p>
            <p>Current Ptr: <span id="trackedIpCurrentPtr">-</span></p>
            <p>Value Reg: <span id="trackedIpValueReg">-</span></p>
            <p>Address Reg: <span id="trackedIpAddressReg">-</span></p>
            <p>Instruction: <span id="trackedIpInstruction">-</span></p>
            <button id="stepButton">Step</button>
            <label><input type="checkbox" id="followIpCheckbox" checked> Follow IP</label>
        </div>
        <h3>Instruction History</h3>
        <div id="instructionHistory" style="max-height: 200px; overflow-y: scroll; border: 1px solid #555; padding: 5px;"></div>
    </div>

    <script>
        // --- Canvas and WebSocket Setup ---
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('soupCanvas');
        const ctx = canvas.getContext('2d');

        // Offscreen canvas for holding the raw soup image
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        const opcodeColors = [
            [46, 46, 46, 255],      // 0: NOOP (Dark Gray)
            [117, 80, 123, 255],    // 1: ADD (Purple-ish)
            [204, 0, 0, 255],       // 2: SUB (Red)
            [245, 121, 0, 255],     // 3: JUMP_REL_IF_LT_ZERO (Orange)
            [0, 255, 255, 255],     // 4: AND (Cyan)
            [255, 0, 255, 255],     // 5: OR (Magenta)
            [128, 0, 128, 255],     // 6: XOR (Dark Purple)
            [0, 128, 128, 255],     // 7: NOT (Teal)
            [52, 101, 164, 255],    // 8: LOAD_VAL_FROM_ADDR (Blue)
            [196, 160, 0, 255],     // 9: LOAD_ADDR_FROM_ADDR (Yellow)
            [78, 154, 6, 255],      // 10: LOAD_VAL_IMMEDIATE (Green)
            [164, 0, 0, 255],       // 11: LOAD_ADDR_IMMEDIATE (Dark Red)
            [255, 255, 255, 255],   // 12: WRITE_VAL_TO_ADDR (White)
        ];

        const opcodeNames = [
            "NOOP",
            "ADD",
            "SUB",
            "JUMP_REL_IF_LT_ZERO",
            "AND",
            "OR",
            "XOR",
            "NOT",
            "LOAD_VAL_FROM_ADDR",
            "LOAD_ADDR_FROM_ADDR",
            "LOAD_VAL_IMMEDIATE",
            "LOAD_ADDR_IMMEDIATE",
            "WRITE_VAL_TO_ADDR",
        ];

        // --- Data Display & Controls ---
        const genSpan = document.getElementById('gen');
        const stepsSpan = document.getElementById('steps');
        const entropySpan = document.getElementById('entropy');
        const jumpRateSlider = document.getElementById('jumpRate');
        const jumpRateValueSpan = document.getElementById('jumpRateValue');
        const opcodeLegendDiv = document.getElementById('opcode-legend');

        // Generate opcode legend
        opcodeNames.forEach((name, index) => {
            const color = opcodeColors[index];
            if (color) {
                const colorBox = `<span style="display:inline-block; width:12px; height:12px; background-color:rgba(${color.join(',')}); border:1px solid #777; vertical-align:middle; margin-right:5px;"></span>`;
                const legendItem = document.createElement('div');
                legendItem.innerHTML = `${colorBox}${name}`;
                opcodeLegendDiv.appendChild(legendItem);
            }
        });

        // --- View State ---
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let soupWidth = 0;
        let soupHeight = 0;
        let isDragging = false; // New flag to detect dragging
        let highlightedIpPtr = -1; // Tracked IP pointer for highlighting

        // --- WebSocket Connection ---
        const socket = new WebSocket('ws://localhost:8080/ws');
        socket.binaryType = 'arraybuffer';

        let imageData;
        let imageDataBuffer;

        function draw() {
            if (!soupWidth) return;

            // Set canvas size to fill container
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            // --- Disable image smoothing for crisp pixels ---
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false; // For Safari
            ctx.mozImageSmoothingEnabled = false;    // For Firefox

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            ctx.drawImage(offscreenCanvas, 0, 0);

            // Highlight tracked IP
            if (highlightedIpPtr !== -1 && soupWidth > 0) {
                const relativePtr = highlightedIpPtr - currentViewStartIndex;
                if (relativePtr >= 0 && relativePtr < (soupWidth * soupHeight)) {
                    const pixelX = relativePtr % soupWidth;
                    const pixelY = Math.floor(relativePtr / soupWidth);

                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2 / zoom; // Adjust line width to scale with zoom
                    ctx.strokeRect(pixelX, pixelY, 1, 1); // Draw 1x1 rectangle, which will be scaled by context.zoom
                }
            }

            ctx.restore();
        }

        socket.onmessage = function(event) {
            if (typeof event.data === 'string') {
                const data = JSON.parse(event.data);
                if (data.Generation !== undefined) {
                    // It's GenerationStats
                    genSpan.textContent = data.Generation;
                    stepsSpan.textContent = (data.StepsPerSecond).toLocaleString();
                    entropySpan.textContent = data.Entropy.toFixed(2);
                } else if (data.ID !== undefined) {
                    // It's an IP state update (SavableIP)
                    trackedIpIdSpan.textContent = data.ID;
                    trackedIpCurrentPtrSpan.textContent = "0x" + data.CurrentPtr.toString(16);
                    trackedIpValueRegSpan.textContent = "0x" + data.ValueRegister.toString(16);
                    trackedIpAddressRegSpan.textContent = "0x" + data.AddressRegister.toString(16);

                    highlightedIpPtr = data.CurrentPtr; // Update highlighted IP pointer

                    // If follow IP is enabled, center the view on the IP
                    if (followIpCheckbox.checked && highlightedIpPtr !== -1 && soupWidth > 0) {
                        const pixelX = highlightedIpPtr % soupWidth;
                        const pixelY = Math.floor(highlightedIpPtr / soupWidth);

                        const targetZoom = 16; // A good zoom level to see the IP

                        // Calculate new offsets to center the IP
                        offsetX = (canvas.width / 2) - (pixelX * targetZoom);
                        offsetY = (canvas.height / 2) - (pixelY * targetZoom);
                        zoom = targetZoom;
                        requestAnimationFrame(draw);
                    }

                    // Display instruction name and color
                    const instructionValue = data.CurrentInstruction;
                    const colorIndex = (instructionValue % opcodeColors.length + opcodeColors.length) % opcodeColors.length;
                    const color = opcodeColors[colorIndex];
                    const instructionName = opcodeNames[colorIndex];

                    trackedIpInstructionSpan.innerHTML = ``; // Clear previous content
                    const colorBox = document.createElement('span');
                    colorBox.style.display = 'inline-block';
                    colorBox.style.width = '12px';
                    colorBox.style.height = '12px';
                    colorBox.style.backgroundColor = `rgba(${color.join(',')})`;
                    colorBox.style.border = '1px solid #777';
                    colorBox.style.verticalAlign = 'middle';
                    colorBox.style.marginRight = '5px';
                    trackedIpInstructionSpan.appendChild(colorBox);
                    trackedIpInstructionSpan.append(instructionName);

                    // Add to instruction history
                    const historyItem = document.createElement('div');
                    historyItem.textContent = `ID: ${data.ID}, Ptr: 0x${data.CurrentPtr.toString(16)}, Val: 0x${data.ValueRegister.toString(16)}, Addr: 0x${data.AddressRegister.toString(16)}, Instr: ${instructionName}`;
                    instructionHistoryDiv.prepend(historyItem); // Add to the top
                    if (instructionHistoryDiv.children.length > 50) { // Limit history to 50 items
                        instructionHistoryDiv.removeChild(instructionHistoryDiv.lastChild);
                    }
                }
            } else if (event.data instanceof ArrayBuffer) {
                const colorIndices = new Uint8Array(event.data);
                const soupSize = colorIndices.length;
                const canvasSize = Math.sqrt(soupSize);

                if (!imageData || soupWidth !== canvasSize) {
                    soupWidth = canvasSize;
                    soupHeight = canvasSize;
                    offscreenCanvas.width = soupWidth;
                    offscreenCanvas.height = soupHeight;
                    imageData = offscreenCtx.createImageData(soupWidth, soupHeight);
                    imageDataBuffer = imageData.data;
                    // Center the initial view
                    offsetX = (canvasContainer.clientWidth - soupWidth * zoom) / 2;
                    offsetY = (canvasContainer.clientHeight - soupHeight * zoom) / 2;
                }

                for (let i = 0; i < soupSize; i++) {
                    const colorIndex = colorIndices[i] < opcodeColors.length ? colorIndices[i] : 0;
                    const color = opcodeColors[colorIndex];
                    const pixelIndex = i * 4;
                    imageDataBuffer[pixelIndex]     = color[0];
                    imageDataBuffer[pixelIndex + 1] = color[1];
                    imageDataBuffer[pixelIndex + 2] = color[2];
                    imageDataBuffer[pixelIndex + 3] = color[3];
                }
                offscreenCtx.putImageData(imageData, 0, 0);
                requestAnimationFrame(draw);
            }
        };

        // --- Event Listeners ---

        // Pan
        canvasContainer.addEventListener('mousedown', (e) => {
            isPanning = true;
            isDragging = false; // Assume not dragging initially
            canvasContainer.style.cursor = 'grabbing';
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvasContainer.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mouseleave', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) { // Consider it a drag if moved more than 5 pixels
                isDragging = true;
            }
            offsetX += dx;
            offsetY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            requestAnimationFrame(draw);
        });

        // Click to set IP pointer
        canvas.addEventListener('click', (e) => {
            if (isDragging) { // Don't set IP if it was a drag
                isDragging = false; // Reset for next click
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Convert canvas coordinates to soup coordinates
            const soupX = Math.floor((x - offsetX) / zoom);
            const soupY = Math.floor((y - offsetY) / zoom);

            // Calculate the absolute soup address
            const soupAddress = currentViewStartIndex + (soupY * soupWidth) + soupX;

            // Send the command to the server for IP ID 1
            const message = {
                type: "set_ip_ptr",
                id: 1, // Hardcoded for the first IP
                ptr: soupAddress
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });

        // Zoom
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Position of the mouse relative to the zoomed image
            const mouseXInImage = (mouseX - offsetX) / zoom;
            const mouseYInImage = (mouseY - offsetY) / zoom;

            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            const newZoom = zoom * zoomFactor;

            // Clamp zoom level
            const maxZoom = 32;
            const minZoom = canvasContainer.clientWidth / 1024; // Ensure it doesn't get smaller than the view
            zoom = Math.max(minZoom, Math.min(newZoom, maxZoom));

            // Adjust offset to keep the mouse position constant
            offsetX = mouseX - mouseXInImage * zoom;
            offsetY = mouseY - mouseYInImage * zoom;

            requestAnimationFrame(draw);
        });

        // Logarithmic scale conversion functions
        const minLog = Math.log(1);
        const maxLog = Math.log(1000000);
        const minSlider = 0;
        const maxSlider = 100;

        function calculateLogFrequency(sliderValue) {
            const scale = (maxLog - minLog) / (maxSlider - minSlider);
            const logValue = minLog + scale * (sliderValue - minSlider);
            return Math.round(Math.exp(logValue));
        }

        function calculateSliderValue(logFrequency) {
            const scale = (maxSlider - minSlider) / (maxLog - minLog);
            const sliderValue = minSlider + scale * (Math.log(logFrequency) - minLog);
            return Math.round(sliderValue);
        }

        // Jump Rate Slider
        jumpRateSlider.addEventListener('input', (e) => {
            const linearSliderValue = parseInt(e.target.value);
            const newFreq = calculateLogFrequency(linearSliderValue);
            jumpRateValueSpan.textContent = newFreq;
            const message = {
                type: "set_jump_rate",
                value: newFreq
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        });
        
        // --- Command Buttons ---
        const pauseButton = document.getElementById('pauseButton');
        const resumeButton = document.getElementById('resumeButton');
        const stepButton = document.getElementById('stepButton');
        const followIpCheckbox = document.getElementById('followIpCheckbox');

        const prevPageButton = document.getElementById('prevPage');
        const nextPageButton = document.getElementById('nextPage');

        const bit32AddressingCheckbox = document.getElementById('32BitAddressing');
        const relativeAddressingCheckbox = document.getElementById('relativeAddressing');

        const rightPanel = document.getElementById('right-panel');
        const trackedIpIdSpan = document.getElementById('trackedIpId');
        const trackedIpCurrentPtrSpan = document.getElementById('trackedIpCurrentPtr');
        const trackedIpValueRegSpan = document.getElementById('trackedIpValueReg');
        const trackedIpAddressRegSpan = document.getElementById('trackedIpAddressReg');
        const trackedIpInstructionSpan = document.getElementById('trackedIpInstruction');
        const instructionHistoryDiv = document.getElementById('instructionHistory');

        const StatsAndVisSize = 1024 * 1024; // Must match the Go constant
        let currentViewStartIndex = 0;

        function showRightPanel() {
            rightPanel.style.display = 'block';
        }

        function hideRightPanel() {
            rightPanel.style.display = 'none';
        }

        function sendCommand(command) {
            const message = {
                type: "command",
                command: command
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendViewStartIndex(index) {
            const message = {
                type: "set_view_start_index",
                value: index
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendAddressingMode(type, enabled) {
            const message = {
                type: type,
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        function sendTrackingEnabled(enabled) {
            const message = {
                type: "set_tracking_enabled",
                value: enabled ? 1 : 0
            };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        pauseButton.addEventListener('click', () => {
            sendCommand('pause');
            showRightPanel();
            sendTrackingEnabled(true); // Enable tracking when paused
        });
        resumeButton.addEventListener('click', () => {
            sendCommand('resume');
            hideRightPanel();
            sendTrackingEnabled(false); // Disable tracking when resumed
            highlightedIpPtr = -1; // Clear highlight
        });
        stepButton.addEventListener('click', () => sendCommand('step'));

        prevPageButton.addEventListener('click', () => {
            currentViewStartIndex -= StatsAndVisSize;
            if (currentViewStartIndex < 0) {
                currentViewStartIndex = 0;
            }
            sendViewStartIndex(currentViewStartIndex);
        });

        nextPageButton.addEventListener('click', () => {
            currentViewStartIndex += StatsAndVisSize;
            // We don't have SoupSize on the client, so we'll let the server clamp it.
            sendViewStartIndex(currentViewStartIndex);
        });

        bit32AddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_32_bit_addressing', event.target.checked);
        });

        relativeAddressingCheckbox.addEventListener('change', (event) => {
            sendAddressingMode('set_relative_addressing', event.target.checked);
        });

        // Resize Observer
        new ResizeObserver(draw).observe(canvasContainer);

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && rightPanel.style.display === 'block') {
                stepButton.click();
            }
        });

        socket.onopen = function(event) {
            console.log("WebSocket connection established.");
            // Set initial jump rate on the server and UI
            // Calculate initial slider value based on default frequency (1)
            const initialFreq = 1; // This should match the default in vm/vm.go
            jumpRateSlider.value = calculateSliderValue(initialFreq);
            jumpRateValueSpan.textContent = initialFreq;
            jumpRateSlider.dispatchEvent(new Event('input'));
        };

        socket.onerror = function(error) {
            console.error("WebSocket Error: ", error);
        };
    </script>
</body>
</html>
